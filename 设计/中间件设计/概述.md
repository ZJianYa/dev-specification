# 概述

信息化，就是把现实映射成信息，映射成数据。  
因为存储和使用的差异，导致我们必须做许多的处理过程。  

## 数据生命周期

数据的生命周期由数据库负责，由数据库日志去管控。  
程序本身应该只是一个加工数据，处理数据的机器，本身尽可能的不保存任何数据。  

## 程序分层

分层的目的，和网络分层的目的是一样的，为的是分工协作。

### 数据对象概念

由于程序分层需要的数据也是不同的，所以数据必然也会分层：  
PO(Persistant Object) 持久对象  
BO(Business Object) 业务对象  
VO(Value Object) 表现对象，也有人称之为ValueObject  
DTO(Data Transfer Object) 数据传输对象  
DAO(Data access object) 数据访问对象  
POJO(Plain ordinary java object) 简单java对象  

我们在实际开发中使用PO BO，两种Bean之间的转换，靠BeanUtils。  
所有的Bean都需要考虑两种构造方法：无参构造、全参构造。  
对于接口而言，分为基本的RequestEntity和ResponseEntity。  
如果做面向接口的开发，那么意味着一个实体在不同的接口暴露的属性不一样，在不同的接口对于属性校验也并不一样。  

### 实际开发规范

实际情况是，我们很少“规范”的使用VO、BO、PO，因为如果用3种对象就会呈现爆炸式增长。  
BO：因为BO通常已经足够满足VO的所有需求，也可以满足PO，所以BO是用的最多的。  
PO：但是由于PO是自动生成的，所以我们也会经常用PO，或者无意识的使用PO。  
VO：后续我们要求必须启用VO，因为VO可以帮助我们严格控制请求和响应参数，避免因为疏忽引发安全问题。VO和BO彻底分离。  
  这里面使用了VO。VO可以分为两类，Request和Response，实际上两者有时候结构非常相似。  
  每一个接口都可能需要独立的VO，即两个对象，那么这个数量就显得非常的庞大。意味着VO的数量是接口数*2。  
对象转换：如果有VO、BO、PO相互转化的情况，使用BeanUtils即可。  

generator-mybatis：而且我们可以后续考虑改写mybatis generator，以后仅生成PO的属性即可，不需要再生成setter、getter方法。  
generator-swagger：可以很好的定义接口，也可以很好的模拟接口，可以帮我们直接生成VO。(http://editor.swagger.io/)  

### Ctrl

尽量把会话数据控制在这一层，权限控制主要在这一层控制（可能我们控制的时候是更多的是在Filter中）。  
包括Service需要的一些参数可能需要在这一层补充，而不是前端直接传入。  

### Service  

用户传入的只是"指令"，而实际需要完成的各项具体动作基本上都要在这一层完成。  

### DAO

主要功能是执行SQL，实现ORM映射。这一层主要使用PO。  

## TODO

因为VO、PO、BO 3者之间是转换关系，并不是继承关系，所以比较难复用。  
是不是UML可以实现从设计到编码的自动化？也或目前阶段还不能这样解决。  

## 参考

https://www.zhihu.com/question/39651928  
https://stackoverflow.com/questions/1612334/difference-between-dto-vo-pojo-javabeans  