# 概述

一般而言，我们需要把所有的现实映射成数据。  
对于数据访问的控制，对于数据的加工处理形成了数据的流转，数据的流转是现实行为/流程的映射。  

软件 = 程序 + 数据 + 文档。  
程序本身应该只是一个加工数据，处理数据的机器，本身尽可能的不保存任何数据。  
程序分层：分层的目的，和网络分层的目的是一样的，为的是分工协作，同时也是番茄工作法。  
分层和分工的相同之处是，每个人可以专注于自己的实现，接口使我们能够总览全局。综合起来就是我们既能总览全局，又能专注自己的领域。 

信息世界是现实世界的映射，也就是说信息世界其实没有什么更新鲜的东西。  

所谓设计，就如设计模式，我们在抽象通用的东西。  
从不同的角度看设计，可以让我们更好的建立自己的思维。  
设计其实有点方法论，方法都是有适用性的，设计也是如此。  

我把 UML 视为是一个综合性的设计，层面之间/层面内部/生命周期/功能和业务 都考虑在内
UML应该是产品经理工具的一部分，产品经理需要分析业务逻辑的正确性，操作上的可行性，更好的UI方案  
既然最终是人来使用系统，则从业务到最终物理硬件，所有的设计也是可以映射的，即也是可以统一设计的，这是UML的基础。  

## 意义

理论上的可行性研究，可以避免盲目的实践。  
可以非常简练的，清晰的展示整个系统的架构，并通过注解对架构做说明。  
组件之间的关系，通常应该是接口之间的关系：组合、依赖。 

- 能够找出可行方法，可行的方法往往是仅考虑正常情况，或者“少数”情况下的  
- 能够找出更优方法，如邓工所述识优劣  
- 能够找出更健壮的方法，对异常的处理往往能够体现出程序的健壮性，伸缩性更好，可扩展性也具有了远瞻性  
- 能够找出更方便维护/更便捷的方法，可扩展性往往会引入复杂性，复杂性往往意味着增加维护的难度  
- 灵活性也会增加维护成本，比如Javascript vs Java  

## 目标

良好的设计工具，从设计到落地的工具。  
对业务/设计/编码/测试/运维人员都友好，都可以工具化，智能化，自动化。  
本质上实际是对意图的理解，

## 分类

### 按照层次分

接口化，既是自律也是自由。  
接口达成了共识：IO数量/类型/规则的共识，接口之间协作的共识。  
面向接口设计，就是API设计。  

#### 视图层/表现层/接口/服务

JSON/XML/HTML，或者交由客户端 Android/iOS/pad/分离的前端  
用户友好型: 所有用户信息是免填写的，所有权限信息是无感知的  
后端友好型: 尽可能的减少向后端的请求，比如一些校验; 前端的复杂操作，也尽可能的不要后端协助服务  

#### 控制层

尽量把会话数据控制在这一层，权限控制主要在这一层控制（可能我们控制的时候是更多的是在Filter中）。  
包括Service需要的一些参数可能需要在这一层补充，而不是前端直接传入。  
控制会话，用户识别和权限控制，功能分离  
https://blog.csdn.net/u012881904/article/details/77194851
  Controller中的校验，把校验脱离出来，但是在这样可能导致的是，无法从接口中直接看到参数是否必录  

#### 服务层

用户传入的只是"指令"+"数据"，而实际需要完成的各项具体动作基本上都要在这一层完成。 

#### DAO

主要功能是执行SQL，实现ORM映射。这一层主要使用PO。

#### 数据库层

数据库类型  
排序/分库分表/查询条件  
删除的数据采用垃圾桶策略，而不是采用字段标识的方式，这样的好处是需要改动的部分只有DELETE功能，坏处是数据会产生大量冗余。  
所有基础数据，被依赖的数据一旦进入垃圾桶，则意味着关联数据都将无法查看。  

### 模型设计  

这里所述的模型设计，其实和上面分层设计是重合的，只是角度不一样。  

由于程序分层需要的数据也是不同的，所以数据必然也会分层：  
PO(Persistant Object) 持久对象  
BO(Business Object) 业务对象  
VO(Value Object) 表现对象，也有人称之为ValueObject  
DTO(Data Transfer Object) 数据传输对象  
DAO(Data access object) 数据访问对象  
POJO(Plain ordinary java object) 简单java对象  

我们在实际开发中使用PO BO，两种Bean之间的转换，靠BeanUtils。  
所有的Bean都需要考虑两种构造方法：无参构造、全参构造。  
对于接口而言，分为基本的RequestEntity和ResponseEntity。  
如果做面向接口的开发，那么意味着一个实体在不同的接口暴露的属性不一样，在不同的接口对于属性校验也并不一样。  

实际情况是，我们很少“规范”的使用VO、BO、PO，因为如果用3种对象就会呈现爆炸式增长。  
BO：因为BO通常已经足够满足VO的所有需求，也可以满足PO，所以BO是用的最多的。  
PO：但是由于PO是自动生成的，所以我们也会经常用PO，或者无意识的使用PO。  
VO：后续我们要求必须启用VO，因为VO可以帮助我们严格控制请求和响应参数，避免因为疏忽引发安全问题。VO和BO彻底分离。  
  这里面使用了VO。VO可以分为两类，Request和Response，实际上两者有时候结构非常相似。  
  每一个接口都可能需要独立的VO，即两个对象，那么这个数量就显得非常的庞大。意味着VO的数量是接口数*2。  
对象转换：如果有VO、BO、PO相互转化的情况，使用BeanUtils即可。  

generator-mybatis：而且我们可以后续考虑改写mybatis generator，以后仅生成PO的属性即可，不需要再生成setter、getter方法。  
generator-swagger：可以很好的定义接口，也可以很好的模拟接口，可以帮我们直接生成VO。(http://editor.swagger.io/)  

#### OOD

OOD 在我看来是 DDD 的基础，不同领域的 O 都是不一样的。  
E-R 设计也是 OOD 的设计，且数据库设计原来也分为 3 层设计。  

#### E-R

#### DDD

在我看来引入 DDD 的概念，会造成 Object 的爆炸

#### TODO

因为VO、PO、BO 3者之间是转换关系，并不是继承关系，所以比较难复用。  
是不是UML可以实现从设计到编码的自动化？也或目前阶段还不能这样解决。  

### 生命周期

#### 软件生命周期

需求设计人员，没错，需求不是客户提出来就够了去。  
设计人员：必须提供很好的设计工具，页面的组件。  

#### 数据生命周期

### 按照功能

#### 列表/详情/统计

#### 文件管理

#### 报表导出

https://stackoverflow.com/questions/203174/whats-a-good-java-api-for-creating-word-documents  
POI导入/导出  

使用场景：某些用户不具有录入信息的权限，且不对外开放注册功能，或有某些信息由专员录入。

#### 数据可视化

### 程序设计

http://www.cnblogs.com/davenkin/p/6612656.html 领域事件
http://www.uml.org.cn/sjms/201211023.asp#2 设计模式6大原则

封装(指令/数据）/重载/继承(多态)/命名空间/泛型/模板/
OOP/AOP/函数式/反应式/异步编程，链式调用
插件式/继承式/组合式/has/切面式

代码进化  
模板的魅力，从邮件模板，到SQL模板  
函数模板，公式模板。  

重复的事情-->抽离封装  
复杂的事情-->拆解  
多变的事情-->把排列问题降解为组合问题  
手工的事情-->自动化  
从可用-->高效/安全  

分层，分模块，工具类，日志管理，文档管理，权限管理，流程管理，常规数据管理，大数据管理  
消息总线，CAS  

工具类
http://blog.csdn.net/rickiyeat/article/details/52512355 工作日/节日问题
http://www.importnew.com/19761.html guava库函数式编程

分布式/微服务

##### 抽象

过程抽象：面向接口编程，函数式编程，AOP  
数据结构抽象/泛型化：模板  
封装：面向对象编程  

### 数据设计

抽象化（业务无关化）/代数化，逻辑ID  
中间数据  
数据预处理  