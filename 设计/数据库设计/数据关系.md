# 概述

静态关系，实际是关系持久化  
数据库的数据是活的  

- 多维度排序  
  所有单位的管理人员应该按单位分组

- 常见的数据格式处理，数据类型与场景  
  时间，或者压根不处理，用long  字符串和数字  
  所有的INT数据都应该是long，所有的xxx数据都应该是byte。  

- 常量和枚举值  
  总有些数据要在界面写死，比如要修改的状态，除非固化成各种接口

- 字典表，场景  
  所有的选择项都会面临元数据的问题。  

- 范式
  范式要解决的问题：解耦合，降低数据冗余  
  但是解决不了的是降低查询SQL复杂度  

## 关联表

- 批量插入，因为一对多/多对多的原因，导致插入的时候，需要循环遍历  
  要么采取补齐主表ID的方式，要么采取只循环子表的方式  
  https://blog.csdn.net/m0_37981235/article/details/79131493 特别注意：mysql默认接受sql的大小是1048576(1M)  
- 根据主表ID，删除关联表。
- 多选框的数据存储
- 复选条件查询，且带有层次关系的查询
- 物理删除/逻辑删除
  https://stackoverflow.com/questions/378331/physical-vs-logical-soft-delete-of-database-record  Physical vs. logical / soft delete of database record?

尽量把判断逻辑放在SQL之外，除非需要判断是正常情况属于业务需要  

### 冗余设计

范式设计，仅仅考虑了数据冗余性，在实际工程中，还需要考虑SQL的复杂性，所以适当冗余表设计是必要的。  
设计依赖关系要考虑数据是变化的，传递依赖的关系发生变化的时候，会出现关联数据缺失。  

### 完整性设计

由于逻辑设计、物理设计的分离，导致逻辑关系的完整性在物理层面无法执行。

#### 更新

对于关联更新，要十分小心，关联表最好不要用ID也不要建ID，因为关联表的ID会经常变化。  
关联表不建ID字段，而是创建联合主键，最简单。1:N的关联插入  
如果是有type这种情况呢，比如一张表是区域表，而另外的业务表需要指定区域。第一感觉是加字段区分type  

#### 删除

关联关系的稳定性，比如网站和漏洞的关联关系是强关联，和单位的关联关系是弱关联。  
用户可以查看到单位下面的所有网站，所有任务。将来用户如果发生调岗、升迁，那么这些数据理应看不到，所以要么不存储用户ID，或者查询要做外关联。  

## 数字or字符

状态到底是数值好，还是字符好？  

## 数据状态，可见性

已经上报过的不可以再上报，数据可见性

## 动作和状态

设计的东西并无高深之处，但是随着分工的不同，在不同的岗位上，技术的差异会越来越大。

## 数据的意义

- 时间  
  update_date和其他的不一样，这样数据默认按照update_date来排序，update_time的意义 time is null  
- 操作人员信息  
  权限，业务数据存储部门和用户ID的必要性  

mysql性能 or 和union all,union  

## 流程化 vs 状态化

## 字典表

字典表的初衷和使用规范

dictionary_class {class_id,class_name:分类名称}
dictionary_item {class_id,item_id,item_name:条目名称,parent_id}

## 数据生命周期

删除的数据采用垃圾桶策略  