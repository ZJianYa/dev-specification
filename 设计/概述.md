# 概述

设计：前端设计，后端设计，通用设计，功能设计  
所有的设计都应该是适配一定的场景，即用一些模式解决一些本质相同的问题  

## WHY

1. 增强了远瞻性，减少返工：走一步看一步，会导致返工  
2. 丰富的经验是设计的基础，良好的经验是良好设计的基础  
3. 架构师存在:是为了方便开发，方便维护，方便扩展。架构师是一个领路人。一个领路人必然走过很多路，想过很多事。  

扩展性，维护性：  
易扩展，未必意味着易维护，比如Javascript  

我们以前的时候热衷于搞清楚概念，而现在我们热衷于搞清楚问题的定义，解决方法、工具，最后再给（问题、方法、工具）一个合适的名字。

## 本质

指令式、方法式、编程式最终的抽象是什么，解决什么问题？  
指令：类似于函数式的效果，但是实现难度更大，使用方法也不同，输入和输出也不同  
方法式：封装、模块化、复用  
编程式和函数式很像：更便于描述过程和逻辑  
反应式：更强调IO，但是在我看来还是对方法的抽象，promise的方式解决其实就很好  

即便是前端也开始通过指令调用组件。  

以前我很少把分形当回事，但是现在发现他是如此的普遍。普遍到就像日常的数学公式，你无法忽略。
相似产生相似，分形是否产自惯性。物质的分布和能量的分布。你学习(姐)是为了帮助他(甥)走上巅峰，能帮的越多当然会越好。找到人与人之间的合作之处，才有共同话题，才有相处的必要。  
主动，可以帮助你更好的赢得未来。主动是一件吃力的事情，当你主动到一定程度，必然会获得更高的汇报，也会赢得别人的主动。  

## 分层

分层的好处之一是分工  
分层和分工的相同之处是，每个人可以专注于自己的实现，接口使我们能够总览全局。综合起来就是我们既能总览全局，又能专注自己的领域。

## 面向接口，API  

接口化，既是自律也是自由。  

前端友好型设计（所有用户信息是免填写的，所有权限信息是无感知的），后端友好型设计：前端已有的数据是不会重新请求后端的，前端的复杂操作，对于后端而言是无感知的。  

接口只是一个通道，界面上的数据（ViewModel和DataModel）和数据关系，校验规则。  

更少的代码量，更多的记忆（API和数据），所有的更好用，使用了更多的约定，以及更完善的说明。  
面向接口设计，就是API设计。  

### 基本接口规范

### 接口的组合和耦合

### 接口设计

1. 接口设计，增删改查：
    - 查询：翻页查询，下拉选项查询，关联查询，多条件查询，模糊查询  
    - 插入：关联插入，批量插入需要返回主键。  
      插入之后有时返回数量即可，有时则可能需要返回对象。  
    - 更新：关联更新  
      有些修改，比如用户信息修改，不能修改密码。
    - 删除：关联删除
  
2. 接口设计，一般规范：
    1. 数据结构的统一
    2. 版本
    3. 回调反馈、超时时间、数值校验、规则校验，数据校验是组件的健壮性的基本保障，异常的友好提示，文档的完整性。  
    4. 友好提示，异常处理

3. 数据类型  
  我们不建议在Java中使用枚举值，因为数据库中的枚举值都是可以增加的，而Java中不行  
  我们也不建议在Java中使用常量，更不建议在前端编码中使用常量  

## 建模

UML应该是产品经理工具的一部分，产品经理需要分析业务逻辑的正确性，操作上的可行性，更好的UI方案  
既然最终是人来使用系统，则从业务到最终物理硬件，所有的设计也是可以映射的，即也是可以统一设计的，这是UML的基础。  

### 价值

理论上的可行性研究，可以避免盲目的实践。  
可以非常简练的，清晰的展示整个系统的架构，并通过注解对架构做说明。  
组件之间的关系，通常应该是接口之间的关系：组合、依赖。  

从原型图(视图层,控制层)-->数据层  
更多的我们不仅想拖拖拽拽，而且还想进行编码。  
另外我们也想做图库，直观的看到流量。  

## 数据

数据存储
数据展示/编辑
数据管理
数据驱动世界

数据关系:线性、集合、树状、图(Map和非Map)。  
数据关系维护：CAP和事务
业务对象的唯一标识是否可以修改？引入版本化之后的问题。可以做账号迁移、合并(可能引起冲突)和删除。  

从数据格式化到数据管理系统。  
从数据文档化到文档管理系统。  

### 数据定义

因为分层的缘故，分层映射的需要，需要对象之间映射、转换  

PO(Persistant Object) 持久对象  
BO(Business Object) 业务对象  
VO(Value Object) 表现对象  
DTO(Data Transfer Object) 数据传输对象  
DAO(Data access object) 数据访问对象  
POJO(Plain ordinary java object) 简单java对象  
我们在实际开发中使用PO BO，两种Bean之间的转换，靠BeanUtils。  
所有的Bean都需要考虑两种构造方法：无参构造、全参构造。  
对于接口而言，分为基本的RequestEntity和ResponseEntity。  
如果做面向接口的开发，那么意味着一个实体在不同的接口暴露的属性不一样，在不同的接口对于属性校验也并不一样。  

## 会话设计

我认为,token和session一样可以自动刷新(有效期)  
当然也可以认为的刷新有效期，或者刷新token  
会话的失效  
会话的安全  

## 设计人员

需求设计人员，没错，需求不是客户提出来就够了去。
设计人员：必须提供很好的设计工具，页面的组件。比如Modeler。

## 常见模式  

大多数的模式，最终都是为了提高代码复用性，提高代码灵活性，提高可拓展性

组件化、模块化和插件化的区别。  

### 模板化  

代码进化  
模板的魅力，从邮件模板，到SQL模板  
函数模板，公式模板。  

### 接口化，封装  

封装：是模块化、接口化的基础。也是所谓的指令化。  
变量私有化，可以避免全局冲突，空间隔离。  
接口解耦可以抽象依赖，不能消除依赖。  
泛型，经常会和接口或者对象一起使用。  
接口是对象的抽象，对象是接口的实现。  

### 对象化  

对象可以看做是接口的实现。虽然接口也可以继承、覆盖、多态，但是通常认为这些特性都是面向对象的思想。
解决问题：不同/相同的输入，相同的产出；相同的输入，不同的处理方式  
抽象和实现，是说 具体问题具体分析，但是又要找出共性  
数据之上，为之道；道不离术，无术不足以行，不求道不足以远行。  
术是具体问题具体分析，根据实际情况解决问题；道是通用解决方法，道是算法复杂度的计算，道是计算长远趋势。  

### 模块化设计  

插件式/切面式/组合式。
我们希望的是：加入某个模块，就具有某种特性。有时候插拔不是一件容易的事情，尤其是产生依赖交互的情况下。可缺和可替换是两码事，可替换和可升级不是一回事。  
模块和对象有着很高的相似性，可能是继承、协作等关系。  

- 通用，抽象，算法  
  抽象和泛型化，是将数据虚化  
  没有业务意义的字段，比如ID，其实也是虚化数据  
  组合排列，是将具体的数据组装，并非虚化  
  纯粹的算法函数是业务无关的  
  通用化的实现方法：泛型化，接口化，标准化，算法抽象，归类，排列组合(分解至相同)。
  算法中有动态规划，动态规划的价值在于将看似复杂繁琐的事情，细细归类，降解为单一的....  

## 代码进化

“琐碎的，反复的，多变的”能不能通过动态规划降解为”简单的、重复的、变化有限的”。  
算法不断的从低端进化到高端。  
以至于解决生活中的方方面面。从而解放人，人越自由，可竞争的空间越大，于是可以形成两极分化。  

## 参考

http://www.cnblogs.com/davenkin/p/6612656.html 领域事件
http://www.uml.org.cn/sjms/201211023.asp#2 设计模式6大原则

## 工具

https://about.draw.io example  
draw.io可以绘制原型图  